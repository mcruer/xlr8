#' @importFrom dplyr slice pull filter
extract_form_name <- function(raw_df){
  raw_df %>%
    filter(sheet_name == "form") %>%
    slice(1) %>%
    pull(x1)
}


#' Summarize Metadata Extracted from Excel Templates
#'
#' Parses and summarizes structured metadata tags embedded in Excel templates, extracting details
#' about variables, tables, and columns. It identifies metadata annotations indicating cell-specific data,
#' table structures, and column definitions.
#'
#' @param raw_template Tibble generated by \code{\link{read_excel_all}}, containing Excel cell data
#'   in a structured, wide-format tibble.
#'
#' @return A tibble containing four list-columns:
#'   \itemize{
#'     \item \code{variable_info}: Tibble of metadata describing individual cells (variables), including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet where variable is located.
#'         \item \code{row_start}, \code{col_start}: Position (row and column) of the cell.
#'         \item \code{tbl}: Variable name.
#'       }
#'
#'     \item \code{table_info}: Tibble summarizing each table in the metadata, including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet name of the table.
#'         \item \code{tbl}: Table name extracted from metadata.
#'         \item \code{row_start}, \code{row_end}: Row range covered by the table.
#'         \item \code{col_start}, \code{col_end}: Column range covered by the table.
#'       }
#'
#'     \item \code{column_info}: Tibble detailing columns within each table, including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet name containing the column.
#'         \item \code{tbl}: Associated table name.
#'         \item \code{col}: Column position (relative to table, starting from 1).
#'         \item \code{col_name}: Name of the column extracted from metadata.
#'       }
#'
#'     \item \code{all_info}: Combined tibble of both variables and columns, ready for downstream use
#'       in data writing and styling.
#'   }
#'
#' @details
#' This function expects the input (\code{raw_template}) to have metadata tags embedded using
#' a special annotation format (defined by \code{xlr8_tag}). It extracts:
#'
#' \itemize{
#'   \item Individual cell annotations (variables) indicated by the tag pattern \code{*((var*((...))}.
#'   \item Table start/end points marked by tags like \code{*((tbl*((...))} and \code{*((table_end}.
#'   \item Column definitions within tables, using the \code{*((col*((...))} tag pattern.
#' }
#'
#' It performs rigorous checks for alignment errors (such as columns not aligned with tables)
#' and explicitly stops execution with clear diagnostic messages if such issues occur.
#'
#' @examples
#' \dontrun{
#' raw_template <- read_excel_all("template.xlsx")
#' metadata <- summarize_metadata_from_raw_template(raw_template)
#' metadata$variable_info  # View extracted variables
#' metadata$table_info     # View summarized table metadata
#' }
#' @importFrom stringr str_c str_remove str_remove_all
#' @importFrom dplyr rename relocate mutate select arrange group_by ungroup lead left_join summarise bind_rows
#' @importFrom tidyr fill pivot_longer
#' @importFrom magrittr subtract
#' @importFrom tibble tibble
#' @importFrom gplyr replace_with_na quickm to_number filter_in
#' @noRd
summarize_metadata_from_raw_template <- function (raw_template) {

  form <- extract_form_name(raw_template)

  # Helper function to extract target metadata (var, tbl, col) from a string
  target_extraction <- function (string, target) {
    # Construct regex pattern to match specific tag
    front <- str_c(".*", xlr8_tag, target, xlr8_tag)


    # Remove the part matching the pattern, then any trailing tag, replacing empty matches with NA
    str_remove(string, front) %>%
      str_remove(str_c(xlr8_tag, ".*")) %>%
      replace_with_na("^$")

  }

  # Process the raw template to extract metadata tags
  tags <- raw_template %>%
    pivot_longer(-c(row, sheet_name)) %>%  # Pivot table to long format (wide to long transformation)
    quickm(name, str_remove, "x") %>%  # Remove the "x" prefix from column names
    to_number(name) %>%  # Convert column names to numeric values
    rename(col = name) %>%  # Rename column to 'col' for clarity
    relocate(row, col, .after = sheet_name) %>%  # Reorder columns for readability
    filter_in(value, str_c("^", xlr8_tag), na.rm = TRUE) %>%  # Keep rows with xlr8 tag values
    mutate(
      # Extract variable names, table names, and column names using helper function
      var = target_extraction(value, "var"),
      tbl = target_extraction(value, "tbl"),
      col_name = target_extraction(value, "col"),
      # Identify table end markers
      table_end = value == str_c(str_remove_all(xlr8_tag, "\\\\"), "table_end")
    )

  # Extract metadata for individual variables
  variable_info <- tags %>%
    filter(!is.na(var)) %>%  # Keep only rows with variable names
    select(sheet_name, row, col, var)  # Select relevant columns

  # Identify table start and end rows
  table_lengths <- tags %>%
    filter(!is.na(tbl) | table_end) %>%  # Keep table rows or table_end markers
    arrange(sheet_name, col, row) %>%  # Sort by sheet, column, and row
    group_by(sheet_name, col) %>%  # Group by sheet and column
    mutate(table_end_row = lead(row)) %>%  # Get the row after each table start as table end
    filter(!is.na(tbl)) %>%  # Keep only table rows
    ungroup() %>%  # Ungroup to flatten
    select(sheet_name, row, col, tbl, end_row = table_end_row)  # Select relevant columns

  # Build interim table information with column associations
  table_info_interim <-
    tags %>%
    filter(!is.na(col_name))  %>%  # Keep rows with column names
    arrange(sheet_name, row, col) %>%  # Sort data by position
    fill(tbl, .direction = "down") %>%  # Fill down table names to associate columns with tables
    select(sheet_name, row, col, tbl, col_name) %>%  # Select relevant fields
    left_join(table_lengths) %>%  # Merge with table lengths (start-end rows)
    group_by(sheet_name, tbl) %>%  # Group by sheet and table
    suppressMessages()  # Suppress any warnings during processing

  # Handle cases where no table information exists
  if (nrow(table_info_interim) == 0) {
    table_info <- tibble(
      sheet_name = factor(),
      tbl = character(),
      row_start = double(),
      row_end = double(),
      col_start = double(),
      col_end = double()
    )
    column_info <- tibble(
      sheet_name = factor(),
      col = double(),
      tbl = character(),
      col_name = character()
    )
  } else {
    # Identify misaligned columns (errors) and stop if found
    errors <- table_info_interim %>%
      filter(min(row) != max(row) | is.na(tbl)) %>%  # Check for rows where min/max row differ
      select(-end_row) %>%  # Remove end_row for clean error reporting
      ungroup()

    if (nrow(errors) > 0) {
      stop(
        paste0(
          "See table below. One or more of the tables has a column that is",
          " not aligned with a table:",
          paste(head(capture.output(print(errors)), 10), collapse = "
")
        )
      )
    }

    # Summarize final table information
    table_info <- table_info_interim %>%
      fill(end_row, .direction = "down") %>%  # Fill down end_row values
      summarise(
        row_start = min(row),
        row_end = mean(end_row),
        col_start = min(col),
        col_end = max(col)
      ) %>%
      ungroup() %>%
      suppressMessages()

    # Extract and format column information
    column_info <- tags %>%
      filter(!is.na(col_name)) %>%
      arrange(sheet_name, row, col) %>%  # Sort by sheet, row, and column
      fill(tbl, .direction = "down") %>%  # Fill table associations downwards
      group_by(sheet_name, tbl) %>%
      # Adjust column positions to start from 1 within each table
      mutate(col = col %>% subtract(min(col) - 1)) %>%
      select(sheet_name, col, tbl, col_name) %>%  # Select relevant fields
      ungroup()
  }

  variable_info_reformed <- variable_info %>%
    rename(tbl = var,
           row_start = row,
           col_start = col) %>%
    mutate(row_end = row_start,
           col_end = col_start)

  all_info <- table_info %>%
    left_join(column_info) %>%
    mutate(col = col - 1,
           col_start = col_start + col) %>%
    select(-col) %>%
    bind_rows(variable_info_reformed) %>%
    mutate(
      form = form,
      row_id = if_else (is.na(col_name),
                        str_c(form, tbl, sep = " "),
                        str_c(form, tbl, col_name, sep = " ")), .before = 1
    ) %>%
    relocate(row_id, .before = 1)


  # Return results as a tibble with variable, table, and column info
  tibble(
    variable_info = list(variable_info),
    table_info = list(table_info),
    column_info = list(column_info),
    all_info = list(all_info)
  )
}


#' Summarize Metadata Directly from an Excel Template File
#'
#' Reads an Excel template file and summarizes structured metadata tags embedded in the sheets,
#' extracting comprehensive details about variables, tables, and column definitions.
#' This function is a convenient wrapper around \code{read_excel_all()} followed by internal metadata parsing.
#'
#' @param metadata_path File path to the Excel template workbook.
#' @param sheets Optional character vector specifying exact sheet names to read.
#'   Defaults to \code{NULL}, in which case sheets matching \code{sheets_regex} are read.
#' @param sheets_regex Regular expression pattern to select sheets when \code{sheets} is \code{NULL}.
#'   Defaults to \code{"."}, matching all sheets.
#'
#' @return A tibble containing structured metadata organized into four list-columns:
#'   \itemize{
#'     \item \code{variable_info}: Metadata describing individual cells (variables), including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet where variable is located.
#'         \item \code{row_start}, \code{col_start}: Position (row and column) of the variable.
#'         \item \code{tbl}: Name assigned to the variable.
#'       }
#'
#'     \item \code{table_info}: Metadata summarizing each table identified in the Excel template, including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet name containing the table.
#'         \item \code{tbl}: Table name extracted from metadata tags.
#'         \item \code{row_start}, \code{row_end}: Row range of the table.
#'         \item \code{col_start}, \code{col_end}: Column range of the table.
#'       }
#'
#'     \item \code{column_info}: Metadata detailing columns within each table, including:
#'       \itemize{
#'         \item \code{sheet_name}: Sheet name containing the column.
#'         \item \code{tbl}: Associated table name.
#'         \item \code{col}: Column position relative to its table (starting from 1).
#'         \item \code{col_name}: Name assigned to the column.
#'       }
#'
#'     \item \code{all_info}: Combined metadata tibble containing both variable and column information
#'       suitable for subsequent data-writing and styling functions.
#'   }
#'
#' @details
#' The Excel template must have metadata annotations embedded using a predefined format (\code{xlr8_tag}),
#' which enables the structured identification of variables, tables, and columns. Specifically, this function:
#'
#' \itemize{
#'   \item Extracts metadata from single-cell variables indicated by tags like \code{*((var*((...))}.
#'   \item Identifies tables by start/end markers like \code{*((tbl*((...))} and \code{*((table_end}.
#'   \item Extracts column definitions within tables using \code{*((col*((...))} tags.
#' }
#'
#' The function performs extensive internal checks for errors such as misaligned columns or incomplete metadata.
#' If misalignments or other issues are detected, the function stops execution and provides clear, explicit
#' error messages to facilitate correction.
#'
#' Users who require separate control over reading Excel sheets and summarizing metadata
#' can independently use \code{read_excel_all()} and internal summarization functions.
#'
#' @examples
#' \dontrun{
#' metadata <- summarize_metadata("template.xlsx")
#' metadata$table_info  # View detailed table metadata
#' metadata$variable_info  # Inspect extracted variable metadata
#' }
#'
#' @export
summarize_metadata <- function(metadata_path, sheets = NULL, sheets_regex = ".") {
  raw_template <- read_excel_all(metadata_path, sheets, sheets_regex)
  summarize_metadata_from_raw_template (raw_template)
}
