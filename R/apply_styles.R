
#' Apply Extracted Excel Styles to Workbook Data
#'
#' Applies Excel cell formatting styles—extracted from an original template workbook—to newly populated data in a workbook. This function ensures that data written using \code{write_data()} is formatted consistently according to the original Excel template's styles.
#'
#' @param wb An Excel workbook object (from \code{openxlsx::loadWorkbook()}) to which data has already been written.
#' @param all_info Tibble containing structured metadata generated by \code{summarize_metadata()}, specifying precisely where data and styles should be applied.
#' @param df Data frame containing data written into the workbook, used for determining styling ranges.
#' @param cells Data frame returned by \code{tidyxl::xlsx_cells()} containing detailed cell information, including style identifiers (\code{local_format_id}) from the template Excel file.
#' @param formats List object returned by \code{tidyxl::xlsx_formats()} containing detailed definitions of Excel styles extracted from the original template file.
#'
#' @return The Excel workbook object (\code{wb}) with Excel cell styles applied as defined by the original template.
#'
#' @details
#' This function:
#'
#' \enumerate{
#'   \item Extracts cell-formatting definitions (fonts, fills, alignment, number formats, etc.) from the original template workbook (using data from \code{cells} and \code{formats} provided by \code{tidyxl}).
#'
#'   \item Converts these Excel style definitions into R-compatible styles using \code{openxlsx::createStyle()}.
#'
#'   \item Matches these extracted styles with corresponding cell positions defined in the metadata (\code{all_info}), carefully handling two distinct cases:
#'     \itemize{
#'       \item Single-cell styles (variables).
#'       \item Column-based styles (tables spanning multiple rows).
#'     }
#'
#'   \item Applies styles to the newly written data cells using \code{openxlsx::addStyle()}, stacking styles appropriately to prevent loss of previously applied formatting.
#' }
#'
#' The function is careful to handle missing or default formatting values, converting Excel style definitions accurately and robustly into R-compatible equivalents.
#'
#' @examples
#' \dontrun{
#' library(tidyxl)
#' library(openxlsx)
#'
#' wb <- openxlsx::loadWorkbook("template.xlsx")
#' metadata <- summarize_metadata("template.xlsx")
#' df <- tibble::tibble(name = c("A", "B"), value = c(10, 20))
#'
#' wb <- write_data(wb, df, metadata$all_info[[1]])
#'
#' # Extract cell and format information from the template
#' cells <- tidyxl::xlsx_cells("template.xlsx")
#' formats <- tidyxl::xlsx_formats("template.xlsx")
#'
#' # Apply extracted styles
#' wb <- apply_styles(wb, metadata$all_info[[1]], df, cells, formats)
#'
#' openxlsx::saveWorkbook(wb, "styled_populated_template.xlsx", overwrite = TRUE)
#' }
#'
#' @export
apply_styles <- function (wb, all_info, df, cells, formats) {

  create_style <- function (fontName,
                            fontSize,
                            fontColour,
                            numFmt,
                            fgFill,
                            halign,
                            valign,
                            wrapText,
                            textRotation,
                            indent,
                            locked,
                            hidden,
                            textDecoration) {
    createStyle(
      fontName = if (is.na(fontName)) NULL else fontName,
      fontSize = if (is.na(fontSize)) NULL else fontSize,
      fontColour = if (is.na(fontColour)) NULL else fontColour,
      numFmt = numFmt,
      fgFill = if (is.na(fgFill)) NULL else fgFill,
      halign = if (is.na(halign)) NULL else halign,
      valign = if (is.na(valign)) NULL else valign,
      wrapText = wrapText,
      textRotation = if (is.na(textRotation)) NULL else textRotation,
      indent = if (is.na(indent)) NULL else indent,
      locked = if (is.na(locked)) NULL else locked,
      hidden = if (is.na(hidden)) NULL else hidden,
      textDecoration = if (length(textDecoration) == 0) NULL else textDecoration
    )
  }

  # Load cell data and formats
  cells <- cells %>%
    select(local_format_id,
           row_formatting = row,
           col_formatting = col)


  # Tidy the structure and extract format_id and properties
  formatting <-
    # Flatten and convert to tibble
    as_tibble(unlist(formats$local, recursive = TRUE),
              rownames = "path") %>%
    mutate(# Extract the local_format_id (digits at the end of the path)
      local_format_id = as.integer(str_extract(path, "\\d+$")),
      # Extract the property by removing the trailing digits
      property = str_remove(path, "\\d+$")) %>%
    select(-path) %>%
    quickm(property, str_replace_all, "\\.", "_") %>%
    pivot_wider(
      names_from = property,
      values_from = value,
      values_fill = NA
    ) %>%
    parse_guess_all() %>%

    # Step 1: Convert TRUE to decoration terms in their respective columns
    mutate(
      font_bold = ifelse(font_bold == "TRUE", "bold", NA),
      font_italic = ifelse(font_italic == "TRUE", "italic", NA),
      font_strike = ifelse(font_strike == "TRUE", "strikeout", NA),
      font_underline = case_when(
        font_underline == "single" ~ "underline",
        font_underline == "double" ~ "underline2",
        font_underline == "singleAccounting" ~ "accounting",
        font_underline == "doubleAccounting" ~ "accounting2",
        TRUE ~ NA_character_
      )
    ) %>%
    rowwise() %>%
    mutate(textDecoration = list(na.omit(
      c(font_bold, font_italic, font_underline, font_strike)
    )),) %>%
    ungroup() %>%
    select(
      local_format_id,
      fontName = font_name,
      fontSize = font_size,
      fontColour = font_color_rgb,
      numFmt,
      fgFill = fill_patternFill_fgColor_rgb,
      halign = alignment_horizontal,
      valign = alignment_vertical,
      wrapText = alignment_wrapText,
      textRotation = alignment_textRotation,
      indent = alignment_indent,
      locked = protection_locked,
      hidden = protection_hidden,
      textDecoration
    ) %>%
    mutate(fontColour = str_c ("#", str_sub(fontColour, start = 3)),
           fgFill = str_c ("#", str_sub(fgFill, start = 3)),) %>%
    mutate(halign = ifelse(halign == "general", NA, halign))


  openxlsx_styles <- formatting %>%
    mutate (openxlsx_style =
              formatting %>%
              select(-local_format_id) %>%
              pmap(create_style)) %>%
    select (local_format_id, openxlsx_style)

  pull_range <- function (x, y) {
    return(x:y)
  }


  formatting_to_apply <-
    #The Variables and columns need to be treated slightly differently because
    #the formatting for variables is only applied to a single row/col, whereas
    #the formatting for the columns is applied over a column and a number
    #of rows.
    bind_rows(
      all_info_vars(all_info, df) %>%
        mutate(rows = map(row_start, ~.x)),
      all_info_cols(all_info, df) %>%
        mutate(rows = map2(row_start, actual_row_end, pull_range))
    ) %>%
    mutate(
      row_formatting = row_start,
      col_formatting = col_start,
      .before = 1
    ) %>%
    left_join(cells) %>%
    #relocate(local_format_id) %>%
    left_join(openxlsx_styles) %>%
    #relocate(openxlsx_style) %>%
    #mutate(rows = map2(row_start, actual_row_end, pull_range)) %>%
    select(
      local_format_id,
      sheet = sheet_name,
      tbl,
      col_name,
           style = openxlsx_style,
           rows,
           cols = col_start,
           col_name
    )

  formatting_to_apply %>%
    select(sheet,
           style,
           rows,
           cols,
           #col_name
           ) %>%
           mutate(wb = list(wb),
                  stack = TRUE) %>%
             pwalk(addStyle)

           return (wb)
  }

